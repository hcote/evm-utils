import IcoCompute from "@/icons/IcoCompute";
import IcoContractReader from "@/icons/IcoContractReader";
import IcoDataDecoder from "@/icons/IcoDataDecoder";
import IcoDecoder from "@/icons/IcoDecoder";
import IcoENS from "@/icons/IcoENS";
import IcoKeyGen from "@/icons/IcoKeyGen";
import IcoMetadata from "@/icons/IcoMetadata";
import IcoRpcRequest from "@/icons/IcoRpcRequest";
import IcoUnits from "@/icons/IcoUnits";
import Code from "@/ui/Code";
import PageDescription from "@/ui/PageDescription";

export interface Navigation {
  name: string;
  path: string;
  shortDesc: string;
  longDesc: React.ReactNode;
  Icon: React.FC<
    React.SVGProps<SVGSVGElement> & {
      color?: string;
      size?: number;
      className?: string;
    }
  >;
}

export const NAVIGATION: Navigation[] = [
  {
    name: "ETH Unit Converter",
    path: "/unit-converter",
    shortDesc: "Convert between Wei, Gwei, and ETH units",
    longDesc: (
      <>
        <PageDescription spaced={false}>
          What is a Wei? It's the smallest unit of ETH, where{" "}
          <Code>1 ETH = 10^18 wei</Code>. It's the unit the Ethereum network
          works in â€” when you send <Code>1 ETH</Code>, the nodes read it as
          sending <Code>1000000000000000000 wei</Code>.
        </PageDescription>
        <PageDescription>
          What is Gwei? It's another unit of ETH, the one gas prices are often
          expressed in. <Code>0.000000001 ETH = 1 gwei = 1000000000 wei</Code>.
          If a transaction has a gas limit of 21,000 units and the network gas
          price is 1 gwei, you can calculate the fee in ETH as{" "}
          <Code>21000 * 0.000000001 ETH = 0.000021 ETH</Code>.
        </PageDescription>
      </>
    ),
    Icon: IcoUnits,
  },
  {
    name: "Private Key Generator",
    path: "/pk-generator",
    shortDesc:
      "Generate a random EVM private key and address, with support for vanity prefixes or suffixes",
    longDesc: (
      <>
        <PageDescription spaced={false}>
          Private keys control wallets. This page lets you generate your own
          random private key or seed phrase for any EVM blockchain chain.
        </PageDescription>
        <PageDescription>
          If you want more control over the derived public address, utilize the{" "}
          <Code>Prefix</Code>, <Code>Contains</Code>, or <Code>Ends with</Code>{" "}
          inputs and this page will try to find a key that maps to a matching
          address. Once created, you can import to any wallet software and use.
        </PageDescription>
        <PageDescription>
          No private keys, seed phrases, or addresses generated by this page are
          ever stored or recorded.
        </PageDescription>
      </>
    ),
    Icon: IcoKeyGen,
  },
  {
    name: "Transaction Decoder",
    path: "/tx-decoder",
    shortDesc: "Decode a raw EVM transaction to view its contents",
    longDesc: (
      <>
        <PageDescription spaced={false}>
          When a user sends a transaction, the wallet takes inputs such as:
        </PageDescription>
        <pre className="mt-3 bg-[var(--color-surface)] text-[var(--color-text-primary)] text-sm p-4 rounded-lg overflow-x-auto border border-[var(--color-border)]">
          {JSON.stringify(
            {
              chainId: 1,
              type: "eip1559",
              to: "0x70997970c51812dc3a010c7d01b50e0d17dc79c8",
              nonce: 785,
              value: "1000000000000000000",
              maxFeePerGas: "2000000000",
              maxPriorityFeePerGas: "2000000000",
            },
            null,
            2
          )}
        </pre>

        <PageDescription>
          It signs the data and outputs a raw transaction hex, such as{" "}
          <Code>
            0x02ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0.
          </Code>
        </PageDescription>
        <PageDescription>
          As a web3 developer, you may have use cases for decoding this hex to
          see exactly what inputs the transaction was sent with. This page
          allows you to do just that, enter the raw transaction and see it in
          human-readable form.
        </PageDescription>
      </>
    ),
    Icon: IcoDecoder,
  },
  {
    name: "NFT Metadata",
    path: "/nft",
    shortDesc: "Fetch and display metadata for any ERC-721 token",
    longDesc: (
      <>
        <PageDescription spaced={false}>
          NFTs are just tokens on a blockchain that are uniquely identifiable by
          a ID. To give life to these simple tokens, they utilize a{" "}
          <Code>tokenURI</Code> attribute, which is a string that points to a
          url which returns the actual metadata.
        </PageDescription>
        <PageDescription>
          The reason for this is it's much more cost effective to store a url
          string like{" "}
          <Code>ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/1</Code>{" "}
          on-chain than to store a large JSON object.
        </PageDescription>
        <PageDescription>
          This tool lets you query any ERC-721 token's metadata, all you need to
          know is the contract address and the token ID.
        </PageDescription>
      </>
    ),
    Icon: IcoMetadata,
  },
  {
    name: "ENS Lookup",
    path: "/ens",
    shortDesc: "Resolve Ethereum Name Service domains to addresses",
    longDesc: (
      <>
        <PageDescription spaced={false}>
          ENS (Ethereum Name Service) is a decentralized domain name system that
          maps human-readable names like <Code>vitalik.eth</Code> to a wallet
          address. This makes it easier to send and receive funds without the
          need to access and copy/paste your long hex addresses.
        </PageDescription>
        <PageDescription>
          This tool allows you to resolve ENS names to their corresponding
          Ethereum address or reverse lookup an address to find its ENS name, if
          one is set.
        </PageDescription>
      </>
    ),
    Icon: IcoENS,
  },
  {
    name: "Compute Contract Address",
    path: "/compute-address",
    shortDesc:
      "Calculate the deployed-at address for a smart contract given a deployer address",
    longDesc: (
      <>
        <PageDescription spaced={false}>
          When a smart contract is deployed to an EVM network, its address is
          deterministically computed using the sender's address and nonce. This
          allows you to determine a contract's address before actually deploying
          it.
        </PageDescription>
        <PageDescription>
          This tool lets you compute the contract address at a given nonce. Or
          if you want to deploy a contract to a custom address, this page can
          search for the nonce that will generate the vanity address matching
          your inputs.
        </PageDescription>
      </>
    ),
    Icon: IcoCompute,
  },
  {
    name: "Data Decoder",
    path: "/data-decoder",
    shortDesc: "Make transaction data human-readable",
    longDesc: (
      <>
        <PageDescription spaced={false}>
          Ethereum transactions that aren't simple ETH transfers include a{" "}
          <Code>data</Code> field, which encodes function calls and arguments in
          a long hex string that are sent to a smart contract.
        </PageDescription>
        <PageDescription>
          This tool decodes the calldata, extracting function names and input
          arguments, to make it easier to understand what the transaction is
          doing.
        </PageDescription>
      </>
    ),
    Icon: IcoDataDecoder,
  },
  {
    name: "JSON RPC",
    path: "/json-rpc",
    shortDesc: "Send JSON RPC requests to EVM nodes",
    longDesc: (
      <>
        <PageDescription spaced={false}>
          JSON RPC is the communication protocol used by dapps to interact with
          EVM nodes. Every time you check a wallet balance, send a transaction,
          or read smart contract data, you're making a JSON RPC call.
        </PageDescription>
        <PageDescription>
          This tool lets you experiment with these methods directly, making it
          easier to debug, test, and understand how applications communicate
          with the blockchain.
        </PageDescription>
      </>
    ),
    Icon: IcoRpcRequest,
  },
  {
    name: "Contract Reader",
    path: "/contract-reader",
    shortDesc: "Read data from any Ethereum smart contract",
    longDesc: (
      <>
        <PageDescription spaced={false}>
          This tool lets you query read-only functions from any smart contract.
          Simply provide the contract address and ABI, and it will display the
          contract methods available.
        </PageDescription>
      </>
    ),
    Icon: IcoContractReader,
  },
  // {
  //   name: "Network Fees Explained",
  //   path: "/network-fees",
  //   shortDesc: "Understand how Ethereum network fees are calculated, legacy vs type-2 transactions and more.",
  //   Icon: IcoNetworkFee,
  // },
];
